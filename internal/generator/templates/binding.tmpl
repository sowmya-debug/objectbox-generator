// automatically generated by the ObjectBox, do not modify

package {{.Package}}

import (
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
)

{{range $entity := .Entities -}}
type {{$entity.Name}}Binding struct {
	_tab flatbuffers.Table
}

func ({{$entity.Name}}Binding) AddToModel(model *objectbox.Model) {
    {{/* TODO IDs maybe save them to the original file as tag? Or read the already existing generated file as well?*/}}
    model.Entity("{{$entity.Name}}", 1, 10001)
    {{range $property := $entity.Properties -}}
    model.Property("{{$property.Name}}", objectbox.PropertyType_{{$property.ObType}}, 1, 10001001) {{/* TODO property flags*/}}
    {{if len $property.Flags}}model.PropertyFlags(PropertyFlags_ID){{end}}
    {{end}}
    model.EntityLastPropertyId(3, 10001003) {{/* TODO last property*/}}
}

func castFromDynamic(entity interface{}) (*{{$entity.Name}}, error) {
    ent, ok := entity.(*{{$entity.Name}})
    if !ok {
        // Programming error, OK to panic
        // TODO don't panic here, handle in the caller if necessary to panic
        panic("Object has wrong type, expecting '{{$entity.Name}}'")
    }
    return ent, nil
}

func ({{$entity.Name}}Binding) GetId(entity interface{}) (uint64, error) {
	if ent, err := castFromDynamic(entity); err != nil {
	    return 0, err
	} else {
	    return ent.{{$entity.PropertyId.Name}}, nil
	}
}

func ({{$entity.Name}}Binding) Flatten(entity interface{}, fbb *flatbuffers.Builder, id uint64) {
    ent, err := castFromDynamic(entity)
    if err != nil {
        // TODO return error and panic in the caller if really, really necessary
        panic(err)
	}

    // prepare the "offset" properties
    {{range $property := $entity.Properties}}
        {{- if eq $property.FbType "UOffsetT" -}}
    var offset{{$property.Name}} flatbuffers.UOffsetT = 0
            {{- if eq $property.GoType "string"}}
    if len(ent.{{$property.Name}}) > 0 {
        offset{{$property.Name}} = fbb.CreateString(ent.{{$property.Name}})
    }
            {{- else -}}
            TODO offset creation for the {{$property.Name}}, type ${{$property.GoType}} is not implemented
            {{- end -}}
        {{end}}
    {{- end}}

    // build the FlatBuffers object
    fbb.StartObject({{len $entity.Properties}})
    {{range $property := $entity.Properties -}}
    fbb.Prepend{{$property.FbType}}Slot({{$property.FbSlot}},
        {{- if eq $property.FbType "UOffsetT"}} offset{{$property.Name}}
        {{- else if eq $property.Name $entity.PropertyId.Name}} id
        {{- else}} ent.{{$property.Name}}{{end}}, 0)
    {{end}}
}

func ({{$entity.Name}}Binding) ToObject(bytes []byte) interface{} {
	binding := getRootAs{{$entity.Name}}Binding(bytes, flatbuffers.UOffsetT(0))

	return &{{$entity.Name}}{
	{{- range $property := $entity.Properties}}
		{{$property.Name}}: binding.property{{$property.Name}}(),
	{{- end}}
	}
}

func getRootAs{{$entity.Name}}Binding(buf []byte, offset flatbuffers.UOffsetT) *{{$entity.Name}}Binding {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &{{$entity.Name}}Binding{}
	x._tab.Bytes = buf
	x._tab.Pos = n + offset
	return x
}

{{range $property := $entity.Properties}}
func (binding *{{$entity.Name}}Binding) property{{$property.Name}}() {{$property.GoType}} {
	if o := flatbuffers.UOffsetT(binding._tab.Offset({{$property.VTableOffset}})); o != 0 {
	    {{/* TODO review the casts for all types */}}
        {{- if eq $property.GoType "string" -}}
        return string(binding._tab.ByteVector(o + binding._tab.Pos))
        {{- else -}}
        return binding._tab.Get{{$property.FbType}}(o + binding._tab.Pos)
        {{- end}}
	}
	{{if eq $property.GoType "string" -}}
	return ""
	{{- else -}}
    return 0
    {{- end}}
}
{{end}}

func ({{$entity.Name}}Binding) MakeSlice(capacity int) interface{} {
	return make([]{{$entity.Name}}, 0, capacity)
}

func ({{$entity.Name}}Binding) AppendToSlice(slice interface{}, entity interface{}) interface{} {
	return append(slice.([]{{$entity.Name}}), *entity.(*{{$entity.Name}}))
}

{{ end}}
