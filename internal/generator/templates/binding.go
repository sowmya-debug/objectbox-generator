package templates

import (
	"strings"
	"text/template"
)

var funcMap = template.FuncMap{
	"StringTitle": strings.Title,
}

var BindingTemplate = template.Must(template.New("binding").Funcs(funcMap).Parse(
	`// This file was automatically generated by ObjectBox, do not modify

package {{.Package}}

import (
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

{{range $entity := .Entities -}}
type {{$entity.Name}}Binding struct {
}

func ({{$entity.Name}}Binding) AddToModel(model *objectbox.Model) {
    model.Entity("{{$entity.Name}}", {{$entity.Id}}, {{$entity.Uid}})
    {{range $property := $entity.Properties -}}
    model.Property("{{$property.ObName}}", objectbox.PropertyType_{{$property.ObType}}, {{$property.Id}}, {{$property.Uid}})
    {{if len $property.ObFlags -}}
        model.PropertyFlags(
        {{- range $key, $flag := $property.ObFlags -}}
            {{if gt $key 0}} | {{end}}objectbox.PropertyFlags_{{$flag}}
        {{- end}})
        {{- /* TODO model.PropertyIndexId() && model.PropertyRelation() */}}
    {{end -}}
    {{end -}}
    model.EntityLastPropertyId({{$entity.LastPropertyId.GetId}}, {{$entity.LastPropertyId.GetUid}})
}

func ({{$entity.Name}}Binding) GetId(entity interface{}) (uint64, error) {
	return entity.(*{{$entity.Name}}).{{$entity.IdProperty.Name}}, nil
}

func ({{$entity.Name}}Binding) Flatten(entity interface{}, fbb *flatbuffers.Builder, id uint64) {
    {{if $entity.HasNonIdProperty}}ent := entity.(*{{$entity.Name}}){{end -}}

    {{- range $property := $entity.Properties}}
        {{- if eq $property.FbType "UOffsetT"}}
            {{- if eq $property.GoType "string"}}
    var offset{{$property.Name}} = fbutils.CreateStringOffset(fbb, ent.{{$property.Name}})
            {{- else if eq $property.GoType "[]byte"}}
    var offset{{$property.Name}} = fbutils.CreateByteVectorOffset(fbb, ent.{{$property.Name}})
            {{- else -}}
            TODO offset creation for the {{$property.Name}}, type ${{$property.GoType}} is not implemented
            {{- end -}}
        {{end}}
    {{- end}}

    // build the FlatBuffers object
    fbb.StartObject({{$entity.LastPropertyId.GetId}})
    {{range $property := $entity.Properties -}}
    fbb.Prepend{{$property.FbType}}Slot({{$property.FbSlot}},
        {{- if eq $property.FbType "UOffsetT"}} offset{{$property.Name}}, 0)
        {{- else if eq $property.Name $entity.IdProperty.Name}} id, 0)
        {{- else if eq $property.GoType "bool"}} ent.{{$property.Name}}, false)
        {{- else if eq $property.GoType "int"}} int32(ent.{{$property.Name}}), 0)
        {{- else if eq $property.GoType "uint"}} uint32(ent.{{$property.Name}}), 0)
        {{- else}} ent.{{$property.Name}}, 0)
        {{- end}}
    {{end -}}
}

func ({{$entity.Name}}Binding) ToObject(bytes []byte) interface{} {
	table := fbutils.GetRootAsTable(bytes, flatbuffers.UOffsetT(0))

	return &{{$entity.Name}}{
	{{- range $property := $entity.Properties}}
		{{$property.Name}}: table.OffsetAs{{if eq $property.GoType "[]byte"}}ByteVector{{else}}{{$property.GoType | StringTitle}}{{end}}({{$property.FbvTableOffset}}),
	{{- end}}
	}
}

func ({{$entity.Name}}Binding) MakeSlice(capacity int) interface{} {
	return make([]*{{$entity.Name}}, 0, capacity)
}

func ({{$entity.Name}}Binding) AppendToSlice(slice interface{}, entity interface{}) interface{} {
	return append(slice.([]*{{$entity.Name}}), entity.(*{{$entity.Name}}))
}

type {{$entity.Name}}Box struct {
	*objectbox.Box
}

func BoxFor{{$entity.Name}}(ob *objectbox.ObjectBox) *{{$entity.Name}}Box {
	return &{{$entity.Name}}Box{
		Box: ob.Box({{$entity.Id}}),
	}
}

func (box *{{$entity.Name}}Box) Get(id uint64) (*{{$entity.Name}}, error) {
	entity, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if entity == nil {
		return nil, nil
	}
	return entity.(*{{$entity.Name}}), nil
}

func (box *{{$entity.Name}}Box) GetAll() ([]*{{$entity.Name}}, error) {
	entities, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return entities.([]*{{$entity.Name}}), nil
}

func (box *{{$entity.Name}}Box) Remove(entity *{{$entity.Name}}) (err error) {
	return box.Box.Remove(entity.{{$entity.IdProperty.Name}})
}

{{end -}}`))
