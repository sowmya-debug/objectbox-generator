package templates

func Binding() string {
	return `// automatically generated by the ObjectBox, do not modify

package {{.Package}}

import (
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

{{range $entity := .Entities -}}
type {{$entity.Name}}Binding struct {
}

func ({{$entity.Name}}Binding) AddToModel(model *objectbox.Model) {
    model.Entity("{{$entity.Name}}", {{$entity.Id}}, {{$entity.Uid}})
    {{range $property := $entity.Properties -}}
    model.Property("{{$property.ObName}}", objectbox.PropertyType_{{$property.ObType}}, {{$property.Id}}, {{$property.Uid}})
    {{if len $property.ObFlags -}}
        model.PropertyFlags(
        {{- range $key, $flag := $property.ObFlags -}}
            {{if gt $key 0}} | {{end}}objectbox.PropertyFlags_{{$flag}}
        {{- end}})
        {{- /* TODO model.PropertyIndexId() && model.PropertyRelation() */}}
    {{end -}}
    {{end -}}
    model.EntityLastPropertyId({{$entity.LastProperty.Id}}, {{$entity.LastProperty.Uid}})
}

func as{{$entity.Name}}(entity interface{}) (*{{$entity.Name}}, error) {
    ent, ok := entity.(*{{$entity.Name}})
    if !ok {
        // Programming error, OK to panic
        // TODO don't panic here, handle in the caller if necessary to panic
        panic("Object has wrong type, expecting '{{$entity.Name}}'")
    }
    return ent, nil
}

func ({{$entity.Name}}Binding) GetId(entity interface{}) (uint64, error) {
	if ent, err := as{{$entity.Name}}(entity); err != nil {
	    return 0, err
	} else {
	    return ent.{{$entity.IdProperty.Name}}, nil
	}
}

func ({{$entity.Name}}Binding) Flatten(entity interface{}, fbb *flatbuffers.Builder, id uint64) {
    ent, err := as{{$entity.Name}}(entity)
    if err != nil {
        // TODO return error and panic in the caller if really, really necessary
        panic(err)
	}

    // prepare the "offset" properties
    {{- range $property := $entity.Properties}}
        {{- if eq $property.FbType "UOffsetT"}}
            {{- if eq $property.GoType "string"}}
    var offset{{$property.Name}} = fbutils.CreateStringOffset(fbb, ent.{{$property.Name}})
            {{- else if eq $property.GoType "[]byte"}}
    var offset{{$property.Name}} = fbutils.CreateByteVectorOffset(fbb, ent.{{$property.Name}})
            {{- else -}}
            TODO offset creation for the {{$property.Name}}, type ${{$property.GoType}} is not implemented
            {{- end -}}
        {{end}}
    {{- end}}

    // build the FlatBuffers object
    fbb.StartObject({{len $entity.Properties}})
    {{range $property := $entity.Properties -}}
    fbb.Prepend{{$property.FbType}}Slot({{$property.Id}},
        {{- if eq $property.FbType "UOffsetT"}} offset{{$property.Name}}, 0)
        {{- else if eq $property.Name $entity.IdProperty.Name}} id, 0)
        {{- else if eq $property.GoType "bool"}} ent.{{$property.Name}}, false)
        {{- else if eq $property.GoType "int"}} int32(ent.{{$property.Name}}), 0)
        {{- else if eq $property.GoType "uint"}} uint32(ent.{{$property.Name}}), 0)
        {{- else}} ent.{{$property.Name}}, 0)
        {{- end}}
    {{end -}}
}

func ({{$entity.Name}}Binding) ToObject(bytes []byte) interface{} {
	table := fbutils.GetRootAsTable(bytes, flatbuffers.UOffsetT(0))

	return &{{$entity.Name}}{
	{{- range $property := $entity.Properties}}
		{{$property.Name}}: table.OffsetAs{{if eq $property.GoType "[]byte"}}ByteVector{{else}}{{$property.GoType | StringTitle}}{{end}}({{$property.VTableOffset}}),
	{{- end}}
	}
}

func ({{$entity.Name}}Binding) MakeSlice(capacity int) interface{} {
	return make([]{{$entity.Name}}, 0, capacity)
}

func ({{$entity.Name}}Binding) AppendToSlice(slice interface{}, entity interface{}) interface{} {
	return append(slice.([]{{$entity.Name}}), *entity.(*{{$entity.Name}}))
}

type {{$entity.Name}}Box struct {
	*objectbox.Box
}

func BoxFor{{$entity.Name}}(ob *objectbox.ObjectBox) *{{$entity.Name}}Box {
	return &{{$entity.Name}}Box{
		Box: ob.Box({{$entity.Id}}),
	}
}

func (box *{{$entity.Name}}Box) Get(id uint64) (*{{$entity.Name}}, error) {
	entity, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	}
	if ent, err := as{{$entity.Name}}(entity); err != nil {
        return nil, err
    } else {
        return ent, nil
    }
}

// TODO
// func (box *{{$entity.Name}}Box) Remove(entity *{{$entity.Name}}) (err error) {
// 	   return box.Box.Remove(entity.{{$entity.IdProperty.Name}})
// }

{{end -}}`
}
